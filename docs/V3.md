# CARLA V3 控制范式 README

规则约束 + 事件导演 + 物理闭环（面向第一人称人因实验刺激视频批量生成）

---

## 1. 背景与问题定义

你已经验证了两条路径各自的硬伤：

* **V1：只给起终点，交给 CARLA 交通逻辑**
  运动学自然、能遵守信号灯，但 **cut-in / merge lane 等事件强度与时机难以稳定复现**。

* **V2：完全手工设计路径点，只让 CARLA 渲染**
  事件几何可控，但常见实现会落到“逐帧贴轨迹/回放式控制”，导致 **不自然卡顿**，同时 **对红绿灯、让行等规则响应割裂**。你现有代码也包含 deterministic replay 的 `TeleportFollower.apply()` 路径。 

V3 的目标是同时满足：

* **部分掌控运动轨迹**：你能把事件几何、TTC/GAP、触发时机锁到可重复的区间
* **遵守交通规则**：红绿灯、限速、跟车距离、禁止随意闯入对向车道
* **全程物理闭环**：只通过 `throttle/brake/steer` 驱动车辆，避免“贴轨迹回放”带来的不连续

---

## 2. 设计目标

V3 以“刺激生成”而不是“自动驾驶算法研究”为中心，四条硬指标：

1. **可控**：cut-in / merge / red-light conflict 等关键事件能被导演稳定触发
2. **自然**：速度、加速度、横向加速度、yaw 连续，画面无顿挫
3. **可重复**：同步模式 + 固定步长 + 种子，批量渲染一致性高
4. **可验收**：离线质量门禁自动判定通过/失败并给出原因（不靠人工盯视频）

---

## 3. V3 总体架构

V3 不是把 V1 或 V2 推倒重做，而是在你现有工程管线上插入“导演层 + 可插拔控制后端”，并把“回放式贴轨迹”降级为 debug 工具。

你现有工程已经具备稳定的产物与结构：

* `run_scenario.py` 作为主执行入口
* 统一输出：`master_video.mp4 / telemetry.json / telemetry.csv / events.json` 等
* 遥测按 SAE J670 坐标系记录，并包含控制输入 `throttle/brake/steer`
* 规划/验证/渲染链路在技术映射中是完整闭环（SceneEdit→Plan→Validate→Render）
* 规划侧已经具备时间参数化、速度剖面、yaw 平滑、曲率限速等能力，可复用为“短时接管参考轨迹生成”。

### 3.1 V3 组件分层

**A. 规则驱动基线（默认）**

* 用 **Traffic Manager (TM)** 管理 autopilot 车辆：跟车距离、速度差、是否允许变道、是否忽略红绿灯等。TM 的 `ignore_lights_percentage / distance_to_leading_vehicle / auto_lane_change / force_lane_change` 等接口是 V3 的核心控制面。([CARLA][1])

**B. 事件导演层 (Scenario Director)**

* 不再用“逐帧轨迹”控制事件，而是用 **触发条件 + 目标约束 + 干预动作** 的 DSL 去导演 TM
* 例：当 gap/TTC 达标时，对事件车下发 `force_lane_change`，并在事件完成后恢复其正常驾驶参数
* 关键提醒：`force_lane_change` 文档明确写了“无视碰撞风险”，所以导演层必须有门禁。([CARLA][1])

**C. 短时接管控制器（只在必要时启用）**

* 当 TM 难以让某个事件“足够像人 / 足够稳定”时，对“事件车”进入 1–3 秒窗口：
  `autopilot off → 低层控制闭环跟随局部平滑换道曲线 → 交回 autopilot`
* 这一路径复用你已有的“手动控制先例”：例如 `unprotected_left_turn` 走 manual steering（非 autopilot）以保证可靠执行。

**D. 回放式 TeleportFollower（降级为 debug）**

* `render/replay_controller.py: TeleportFollower` 当前在代码映射中标记为 OK。3 不把它作为产线控制后端，只作为“对齐检查 / 可视化复现 / planner 调试”工具，因为它天然会带来运动不连续与规则割裂。

---

## 4. 控制后端选择：是否引入外部自动驾驶模型

V3 支持三档后ffic Manager（强烈推荐默认）
适用：绝大多数刺激生成任务
优势：规则一致性强、参数化干预简单、批量可控
关键点：TM 强烈建议在 **同步模式**使用，否则会出现不可预期结果。([CARLA][2])

### 4.2 后端 2：CARLA Agents（推荐作为补充）

当你想让 ego 更“目的地导向”或更“驾驶风格化”，可以用 CARLA 自带 Agents：

* `BasicAgent`：响应红绿灯但忽略 stop sign
* `BehaviorAgent`：更复杂，考虑信号、标志、限速，并支持 cautious/normal/aggressive 三种行为画像([CARLA][3])

推荐用法：**只替换 ego 的 driver backend**，事件车仍由 TM+导演掌控，避免系统自主规避风险把事件“躲掉”。

### 4.3 后端 3：外部完整自动驾驶栈/模型（慎用）

仅当你明确要研究“某栈的决策风格差异”或要迁移到真实系统评测时再引入。否则集成复杂度、可重复性风险和调参成本都显著上升。

---

## 5. 同步与可重复性设置

### 5.1 同步模式是 V3 的前提

* 世界与 TM 都置为同步模式，避免异步低帧率下 TM 行为异常。([CARLA][2])
* 固定 `fixed_delta_seconds`，让速度/加速度门禁更可靠

### 5.2 种子与端口

* 客户端配置包含 `tm_port`，建议把 TM 端口视为实验配置的一部分，避免多客户端相互干扰。
* TM 支持 deterministic seed，且要求在同步模式下启用。([CARLA][4])

### 5.3 禁用 Hybrid physics（刺激渲染强烈不建议）

TM 的 hybrid physics 会让车辆“以 teleport 方式移动”，这会直接破坏你对自然性与连续性的要求。([CARLA][5])

---

## 6. 事件导演层：事件 DSL 与门禁

V3 不用“每帧轨迹点”，而用“事件意图”描述：

* **触发条件**：时间 / gap / TTC / 距离路口 / 距离匝道末端
* **目标约束**：切入后目标 gap、目标速度差、目标车道、最小 T短时接管
* **后处理**：事件结束后恢复正常驾驶参数，避免后续行为怪异

### 6.1 cut-in 示例

```yaml
events:
  - id: cut_in_01
    type: cut_in
    actor: cut_in_vehicle
    trigger:
      all:
        - gap_m <= 18
        - ttc_s <= 3.0
    action:
      prefer: traffic_manager
      tm:
        auto_lane_change: false
        speed_diff_pct: -10
      execute:
        force_lane_change: left
      post:
        auto_lane_change: true
        distance_to_leading_vehicle_m: 5.0
    fallback:
      controller_override_window_s: 2.0
      lane_change_profile: quintic
```

说明要点：

* `force_lane_change` 是导演层的“硬触发开关”，其行为定义是无视碰撞风险，所以必须前置 gap/TTC 门禁。([CARLA][1])
* 门禁失败时不执行换道，而是先调整速度差与车距，把系统引到目标区间后再触发

### 6.2 merge lane 示例

merge lane 只是在 cut-in 的基础上增加 “匝道末端约束 + 并入窗口”，导演层会：

1. 事件车在匝道线内保持目标速度
2. 进入并入窗口后，等待 gap/TTC 达标触发换道
3. 若 TM 换道不稳定，短时接管做 1–2 秒平滑横向位移，再交回 TM

---

## 7. 运行时循环（单 tick 执行顺序）

推荐统一在 `run_scenario.py` 的 tick 循环中执行：

1. **Director.tick(ctx)**

   * 更新 gap/TTC、路口距离等指标
   * 根据事件状态下发 TM 参数或进入短时接管
2. **DriverBackend.run_step(ctx)**

   * 若 backend 输出 `VehicleControl`：对该 actor `apply_control()`
   * 若返回 None：保持 autopilot/TM 接管
3. **TelemetryRecorder.tick()**

   * 记录 SAE J670 遥测与控制输入
4. **CameraRecorder.capture()**

   * 采集第一人称帧，最终编码到 `master_video.mp4`

---

## 8. 数据产物与溯源一致性

你现有 run 输出结构建议保持不变：

* `scenario.yaml`：本次运行使用的完整配置
* `events.json`：导演层触发与事件检测输出
* `telemetry.json / telemetry.csv`：用于离线门禁、统计、对齐分析
* `master_video.mp4`：第一人称视频
* `run.log`：触发日志与 debug 信息（排查事件未发生非常关键）

另外，你的 Phase G 已经实现了 **SHA256 hash 链溯源**，建议 V3 继续沿用，确保“scene_edit→plan→telemetry→compare_report”一致性可验证。

---

## 9. 质量门禁：把“自然性”做成硬标准

### 9.1 离线门禁（强制r.py` 已覆盖关键异常检测，包括倒车帧、yaw 跳变、速度/加速度越界等。

建议 speed / accel / yaw jump / reverse

* **事件强度TTC、切入完成时 gap 区间

  * merge 并入点位置区间、并入时 TTC 区间
  * red-light conflict：信号灯相位与进入路口时刻

失败策略：自动调整参数并重采样（改 seed 或轻调 speed_diff / trigger window），直到达标。

### 9.2 在线门禁（推荐）

在导演层实时计算 gap/TTC，未达标则过 TM 参数把系统“引导”到可触发区间，再触发。

---

## 10. 工程集成：推荐新增目录与最小改动点

在现有 `carla_experiment_client/` 包下新增：

* `directo:contentReference[oaicite:31]{index=31}iver_backends/`：TM backend、Agent backend、ShortOverride backend
* `control/`：短时接管控制器（PID speed + 横向跟踪 + jerk/acc 限幅、并入进度等在线指标

保持不变的模块：

* `telemetry/`：继续作为唯一事实来源，记录控制输入与状态
* `events/`：继续输出统一的 `events.json`
* `render_presets` 与 trigger scaling：继续沿用，你已支持不同 FPS 下触发帧自动缩放。 

---

## 11. 使用方式（保持与现有 CLI 一致）

你现有 Quick Start 命令建议保持：

```bash
# 按 scenario id 运行
python run_scenario.py --scenario highway_merge --out runs/test

# 指定渲染 preset
python run_scenario.py --scenario highway_merge --render-preset test --out runs/test
```

V3 新增建议的配置入口：

* `configs/natural_driving.yaml`：TM 行为 profile（safe / normal / aggressive / experiment）yaml`：每个 scenario 选择 driver backend 与事件 DSL 参数

---

## 12. 排障与调参工作流（建高 `run.log` 的 trigger 日志，再用 `telemetry.json` 确认关键 actor 距离是否

* spawn 偏移/随机出生：优先用 waypoint 系统生成邻道 spawn，必要时加 spawn 后距离校验
* telemetry 缺 actor：动态重生 actor 后必须加入 `ctx.actors`

---

## 13. 迁移清单：从 V1 / V2 到 V3

### 必做

* 将“回放式贴轨迹”从产线禁用，仅保留 debug

  * 你目前 deterministic replay 路径是显式存在的，固定 `fixed_delta_seconds`([CARLA][2])
* 禁用 hybrid ([CARLA][5])

### 推荐

* 把 trigger 从 frame 逐步迁移到 time/metric 驱动

  * 继续保留 frame scaling 兼容已有 presets
* 将 cut-in/merge 的刺激制器作为 fallback，而不是主路径

---

## 14. 你下一步最值得做的两件事

1. **先把 lane_

   * 只用 TM 干预（speed diff + distance + force_lane_ch

2. **把“事件强度门禁”接到现有 validator/compare_report**

   * 你已经有完善的离线验证与对比工具链，扩展事件指标会非常快.json / events.json / telemetry.csv` 里最关键的 50 行（尤其是发生卡顿的那一段时间窗）贴出来，我可以按你现有字段直接给出一套 **cut-in 门禁阈值 + TM 参数组合 + fallback 接管窗口** 的默认 profile，并告诉你为什么这些阈值能把“自然性”和“刺激强度”同时锁住。



[1]: https://carla.readthedocs.io/en/0.9.8/python_api/?utm_source=chatgpt.com "Python API reference - CARLA Simulator"
[2]: https://carla.readthedocs.io/en/latest/adv_traffic_manager?utm_source=chatgpt.com "Traffic Manager - CARLA Simulator"
[3]: https://carla.readthedocs.io/en/0.9.15/adv_agents/?utm_source=chatgpt.com "CARLA Agents - CARLA Simulator"
[4]: https://carla.readthedocs.io/en/0.9.11/adv_traffic_manager/?utm_source=chatgpt.com "Traffic Manager - CARLA Simulator"
[5]: https://carla.readthedocs.io/en/0.9.9/adv_traffic_manager/?utm_source=chatgpt.com "Traffic Manager - CARLA Simulator"
